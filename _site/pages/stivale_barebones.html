<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <link rel="stylesheet" type="text/css" href="../_/stylesheet.css">

        <title>stivale_barebones - osdev.wiki</title>
        <meta property="og:type" content="article" /><meta property="og:url" content="http://localhost//pages/stivale_barebones.html" /><meta property="og:title" content="stivale_barebones" /><meta property="og:description" content="A tutorial on how to write a minimal kernel using a stivale2-compliant bootloader." />
        <meta name="keywords" content="osdev-wiki,osdev,programming,x86">
        <meta name="description" content="A tutorial on how to write a minimal kernel using a stivale2-compliant bootloader.">
    </head>
    <body>
        <div id="content">
            <svg id="logo" viewBox="0 0 747.13464 126.28621">
                <use href="../_/static/logo.svg#g623"></use>
            </svg>
            <div id="navbar"><a href="../">Main page</a>
</div>
            <div id="contenttop">

                <a id="forgebtn" href="https://github.com/osdev-wiki/wiki/blob/main/pages/stivale_barebones.adoc">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-file-earmark-binary-fill" viewBox="0 0 16 16">
                        <path d="M5.526 10.273c-.542 0-.832.563-.832 1.612 0 .088.003.173.006.252l1.559-1.143c-.126-.474-.375-.72-.733-.72zm-.732 2.508c.126.472.372.718.732.718.54 0 .83-.563.83-1.614 0-.085-.003-.17-.006-.25l-1.556 1.146z"></path>
                        <path d="M9.293 0H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V4.707A1 1 0 0 0 13.707 4L10 .293A1 1 0 0 0 9.293 0zM9.5 3.5v-2l3 3h-2a1 1 0 0 1-1-1zm-2.45 8.385c0 1.415-.548 2.206-1.524 2.206C4.548 14.09 4 13.3 4 11.885c0-1.412.548-2.203 1.526-2.203.976 0 1.524.79 1.524 2.203zm3.805 1.52V14h-3v-.595h1.181V10.5h-.05l-1.136.747v-.688l1.19-.786h.69v3.633h1.125z"></path>
                    </svg>
                </a>

            </div>
            <div id="padding"></div>
            <div id="toc"><ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a>
<ul class="sectlevel2">
<li><a href="#_what_is_stivale">1.1. What is stivale?</a></li>
</ul>
</li>
<li><a href="#_tutorial">2. Tutorial</a>
<ul class="sectlevel2">
<li><a href="#_the_code">2.1. The Code</a></li>
<li><a href="#_building_the_kernel_and_creating_an_image">2.2. Building the kernel and creating an image</a></li>
<li><a href="#_creating_an_iso">2.3. Creating an ISO</a></li>
<li><a href="#_creating_a_hard_diskusb_drive_image">2.4. Creating a hard disk/USB drive image</a></li>
</ul>
</li>
<li><a href="#_conclusion">3. Conclusion</a></li>
<li><a href="#_see_also">4. See Also</a></li>
</ul></div>
<article>
<h1 class="sect0">Stivale Barebones</h1>

<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_what_is_stivale">1.1. What is stivale?</h3>
<div class="paragraph">
<p>This article will demonstrate how to write a small 64-bit higher-half
<a href="#stivale">stivale2</a> kernel in (GNU) C, and boot it using the
<a href="../pages/limine.html">Limine</a> bootloader.</p>
</div>
<div class="paragraph">
<p>It is also recommended to check out
<a href="https://github.com/limine-bootloader/limine-barebones">this</a> project as it
provides example buildable code to go along with this tutorial.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial">2. Tutorial</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_the_code">2.1. The Code</h3>
<div class="paragraph">
<p>For this example, we will create these 2 files and place them in the same directory:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>kernel.c</p>
</li>
<li>
<p>linker.ld</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As one may notice, there is no "entry point" assembly stub, as one is not necessary with either stivale1 or 2, when using a language which can make use of a standard System V x86 <a href="../pages/calling_conventions.html">calling convention</a>.</p>
</div>
<div class="paragraph">
<p>Furthermore, we will download the header file <code>stivale2.h</code> which defines structures that we will use to interact with the bootloader from <a href="https://raw.githubusercontent.com/stivale/stivale/master/stivale2.h">here</a>, and place it in the same directory as the other files.</p>
</div>
<div class="paragraph">
<p>Obviously, this is just a bare bones example, and one should always refer to the <a href="https://github.com/stivale/stivale/blob/master/STIVALE2.md">stivale2 specification</a> for more details and information.</p>
</div>
<div class="paragraph">
<p>This is the kernel "main".</p>
</div>
<div class="listingblock">
<div class="title">kernel.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">#include &lt;stdint.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stivale2.h&gt;

// We need to tell the stivale bootloader where we want our stack to be.
// We are going to allocate our stack as an array in .bss.
static uint8_t stack[8192];

// stivale2 uses a linked list of tags for both communicating TO the
// bootloader, or receiving info FROM it. More information about these tags
// is found in the stivale2 specification.

// stivale2 offers a runtime terminal service which can be ditched at any
// time, but it provides an easy way to print out to graphical terminal,
// especially during early boot.
// Read the notes about the requirements for using this feature below this
// code block.
static struct stivale2_header_tag_terminal terminal_hdr_tag = {
    // All tags need to begin with an identifier and a pointer to the next tag.
    .tag = {
        // Identification constant defined in stivale2.h and the specification.
        .identifier = STIVALE2_HEADER_TAG_TERMINAL_ID,
        // If next is 0, it marks the end of the linked list of header tags.
        .next = 0
    },
    // The terminal header tag possesses a flags field, leave it as 0 for now
    // as it is unused.
    .flags = 0
};

// We are now going to define a framebuffer header tag.
// This tag tells the bootloader that we want a graphical framebuffer instead
// of a CGA-compatible text mode. Omitting this tag will make the bootloader
// default to text mode, if available.
static struct stivale2_header_tag_framebuffer framebuffer_hdr_tag = {
    // Same as above.
    .tag = {
        .identifier = STIVALE2_HEADER_TAG_FRAMEBUFFER_ID,
        // Instead of 0, we now point to the previous header tag. The order in
        // which header tags are linked does not matter.
        .next = (uint64_t)&amp;terminal_hdr_tag
    },
    // We set all the framebuffer specifics to 0 as we want the bootloader
    // to pick the best it can.
    .framebuffer_width  = 0,
    .framebuffer_height = 0,
    .framebuffer_bpp    = 0
};

// The stivale2 specification says we need to define a "header structure".
// This structure needs to reside in the .stivale2hdr ELF section in order
// for the bootloader to find it. We use this __attribute__ directive to
// tell the compiler to put the following structure in said section.
__attribute__((section(".stivale2hdr"), used))
static struct stivale2_header stivale_hdr = {
    // The entry_point member is used to specify an alternative entry
    // point that the bootloader should jump to instead of the executable's
    // ELF entry point. We do not care about that so we leave it zeroed.
    .entry_point = 0,
    // Let's tell the bootloader where our stack is.
    // We need to add the sizeof(stack) since in x86(_64) the stack grows
    // downwards.
    .stack = (uintptr_t)stack + sizeof(stack),
    // Bit 1, if set, causes the bootloader to return to us pointers in the
    // higher half, which we likely want since this is a higher half kernel.
    // Bit 2, if set, tells the bootloader to enable protected memory ranges,
    // that is, to respect the ELF PHDR mandated permissions for the executable's
    // segments.
    // Bit 3, if set, enables fully virtual kernel mappings, which we want as
    // they allow the bootloader to pick whichever *physical* memory address is
    // available to load the kernel, rather than relying on us telling it where
    // to load it.
    // Bit 4 disables a deprecated feature and should always be set.
    .flags = (1 &lt;&lt; 1) | (1 &lt;&lt; 2) | (1 &lt;&lt; 3) | (1 &lt;&lt; 4),
    // This header structure is the root of the linked list of header tags and
    // points to the first one in the linked list.
    .tags = (uintptr_t)&amp;framebuffer_hdr_tag
};

// We will now write a helper function which will allow us to scan for tags
// that we want FROM the bootloader (structure tags).
void *stivale2_get_tag(struct stivale2_struct *stivale2_struct, uint64_t id) {
    struct stivale2_tag *current_tag = (void *)stivale2_struct-&gt;tags;
    for (;;) {
        // If the tag pointer is NULL (end of linked list), we did not find
        // the tag. Return NULL to signal this.
        if (current_tag == NULL) {
            return NULL;
        }

        // Check whether the identifier matches. If it does, return a pointer
        // to the matching tag.
        if (current_tag-&gt;identifier == id) {
            return current_tag;
        }

        // Get a pointer to the next tag in the linked list and repeat.
        current_tag = (void *)current_tag-&gt;next;
    }
}

// The following will be our kernel's entry point.
void _start(struct stivale2_struct *stivale2_struct) {
    // Let's get the terminal structure tag from the bootloader.
    struct stivale2_struct_tag_terminal *term_str_tag;
    term_str_tag = stivale2_get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_TERMINAL_ID);

    // Check if the tag was actually found.
    if (term_str_tag == NULL) {
        // It wasn't found, just hang...
        for (;;) {
            asm ("hlt");
        }
    }

    // Let's get the address of the terminal write function.
    void *term_write_ptr = (void *)term_str_tag-&gt;term_write;

    // Now, let's assign this pointer to a function pointer which
    // matches the prototype described in the stivale2 specification for
    // the stivale2_term_write function.
    void (*term_write)(const char *string, size_t length) = term_write_ptr;

    // We should now be able to call the above function pointer to print out
    // a simple "Hello World" to screen.
    term_write("Hello World", 11);

    // We're done, just hang...
    for (;;) {
        asm ("hlt");
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Using the stivale2 terminal requires that the kernel maintains some state as described in the <a href="https://github.com/stivale/stivale/blob/master/STIVALE2.md\#x86\_64-1">specification</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This is going to be our linker script describing where our sections will end up in memory.</p>
</div>
<div class="listingblock">
<div class="title">linker.ld</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">/* Tell the linker that we want an x86_64 ELF64 output file */
OUTPUT_FORMAT(elf64-x86-64)
OUTPUT_ARCH(i386:x86-64)

/* We want the symbol _start to be our entry point */
ENTRY(_start)

/* Define the program headers we want so the bootloader gives us the right */
/* MMU permissions */
PHDRS
{
    null    PT_NULL    FLAGS(0) ;                   /* Null segment */
    text    PT_LOAD    FLAGS((1 &lt;&lt; 0) | (1 &lt;&lt; 2)) ; /* Execute + Read */
    rodata  PT_LOAD    FLAGS((1 &lt;&lt; 2)) ;            /* Read only */
    data    PT_LOAD    FLAGS((1 &lt;&lt; 1) | (1 &lt;&lt; 2)) ; /* Write + Read */
}

SECTIONS
{
    /* We wanna be placed in the topmost 2GiB of the address space, for optimisations */
    /* and because that is what the stivale2 spec mandates. */
    /* Any address in this region will do, but often 0xffffffff80000000 is chosen as */
    /* that is the beginning of the region. */
    . = 0xffffffff80000000;

    .text : {
        *(.text*)
    } :text

    /* Move to the next memory page for .rodata */
    . += CONSTANT(MAXPAGESIZE);

    /* We place the .stivale2hdr section containing the header in its own section, */
    /* and we use the KEEP directive on it to make sure it doesn't get discarded. */
    .stivale2hdr : {
        KEEP(*(.stivale2hdr))
    } :rodata

    .rodata : {
        *(.rodata*)
    } :rodata

    /* Move to the next memory page for .data */
    . += CONSTANT(MAXPAGESIZE);

    .data : {
        *(.data*)
    } :data

    .bss : {
        *(COMMON)
        *(.bss*)
    } :data
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_building_the_kernel_and_creating_an_image">2.2. Building the kernel and creating an image</h3>
<div class="sect3">
<h4 id="_makefile">2.2.1. Makefile</h4>
<div class="paragraph">
<p>In order to build our kernel, we are going to use a Makefile.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="makefile"># This is the name that our final kernel executable will have.
# Change as needed.
KERNEL := myos.elf

# It is highly recommended to use a custom built cross toolchain to build a kernel.
# We are only using "cc" as a placeholder here. It may work by using
# the host system's toolchain, but this is not guaranteed.
CC ?= cc

# Likewise, "ld" here is just a placeholder and your mileage may vary if using the
# host's "ld".
LD ?= ld

# User controllable CFLAGS.
CFLAGS ?= -Wall -Wextra -O2 -pipe

# User controllable linker flags. We set none by default.
LDFLAGS ?=

# Internal C flags that should not be changed by the user.
INTERNALCFLAGS :=            \
    -I.                  \
    -std=gnu11           \
    -ffreestanding       \
    -fno-stack-protector \
    -fno-pic             \
    -mno-80387           \
    -mno-mmx             \
    -mno-3dnow           \
    -mno-sse             \
    -mno-sse2            \
    -mno-red-zone        \
        -mcmodel=kernel      \
        -MMD

# Internal linker flags that should not be changed by the user.
INTERNALLDFLAGS :=             \
    -Tlinker.ld            \
    -nostdlib              \
    -zmax-page-size=0x1000 \
    -static

# Use find to glob all *.c files in the directory and extract the object names.
CFILES := $$(shell find ./ -type f -name '*.c')
OBJ := $$(CFILES:.c=.o)
HEADER_DEPS := $$(CFILES:.c=.d)

# Default target.
.PHONY: all
all: $$(KERNEL)

# Link rules for the final kernel executable.
$$(KERNEL): $$(OBJ)
    $$(LD) $$(OBJ) $$(LDFLAGS) $$(INTERNALLDFLAGS) -o $$@

# Compilation rules for *.c files.
-include $$(HEADER_DEPS)
%.o: %.c
    $$(CC) $$(CFLAGS) $$(INTERNALCFLAGS) -c $$&lt; -o $$@

# Remove object files and the final executable.
.PHONY: clean
clean:
    rm -rf $$(KERNEL) $$(OBJ) $$(HEADER_DEPS)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_limine_cfg">2.2.2. limine.cfg</h4>
<div class="paragraph">
<p>This file is parsed by Limine and it describes boot entries and other bootloader configuration variables. Further information <a href="https://github.com/limine-bootloader/limine/blob/trunk/CONFIG.md">here</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="ini"># Timeout in seconds that Limine will use before automatically booting.
TIMEOUT=5

# The entry name that will be displayed in the boot menu
:myOS

# Change the protocol line depending on the used protocol.
PROTOCOL=stivale2

# Path to the kernel to boot. boot:/// represents the partition on which limine.cfg is located.
KERNEL_PATH=boot:///myos.elf</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compiling_the_kernel">2.2.3. Compiling the kernel</h4>
<div class="paragraph">
<p>We can now build our example kernel by running <strong>make</strong>. This command, if successful, should generate a file called <code>myos.elf</code> (or the chosen kernel name). This is our stivale2-compliant kernel executable.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creating_the_image">2.2.4. Creating the image</h4>
<div class="paragraph">
<p>We can now create either an ISO or a hard disk/USB drive image with our kernel on it. <a href="../pages/limine.html">/pages/limine.html</a> can boot on both <a href="../pages/bios.html">/pages/bios.html</a> and <a href="../pages/uefi.html">/pages/uefi.html</a> if the image is set up to do so, which is what we are going to do.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_an_iso">2.3. Creating an ISO</h3>
<div class="paragraph">
<p>In this example we are going to create a CD-ROM ISO capable of booting on both <a href="../pages/uefi.html">/pages/uefi.html</a> and legacy <a href="../pages/bios.html">/pages/bios.html</a> systems.</p>
</div>
<div class="paragraph">
<p>For this to work, we will need the <strong>xorriso</strong> utility.</p>
</div>
<div class="paragraph">
<p>These are shell commands. They can also be compiled into a script or Makefile.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sh"># Download the latest Limine binary release.
git clone https://github.com/limine-bootloader/limine.git --branch=v2.0-branch-binary --depth=1

# Build limine-install.
make -C limine

# Create a directory which will be our ISO root.
mkdir -p iso_root

# Copy the relevant files over.
cp -v myos.elf limine.cfg limine/limine.sys \
      limine/limine-cd.bin limine/limine-eltorito-efi.bin iso_root/

# Create the bootable ISO.
xorriso -as mkisofs -b limine-cd.bin \
        -no-emul-boot -boot-load-size 4 -boot-info-table \
        --efi-boot limine-eltorito-efi.bin \
        -efi-boot-part --efi-boot-image --protective-msdos-label \
        iso_root -o image.iso

# Install Limine stage 1 and 2 for legacy BIOS boot.
./limine/limine-install image.iso</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_a_hard_diskusb_drive_image">2.4. Creating a hard disk/USB drive image</h3>
<div class="paragraph">
<p>In this example weâ€™ll create a <a href="../pages/gpt.html">/pages/gpt.html</a> partition table using <strong>parted</strong>, containing a single FAT partition, also known as the <a href="../pages/uefi.html#ESP">ESP</a> in EFI terminology, which will store our kernel, configs, and bootloader.</p>
</div>
<div class="paragraph">
<p>This example is more involved and is made up of more steps than creating an ISO image.</p>
</div>
<div class="paragraph">
<p>These are shell commands. They can also be compiled into a script or Makefile.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="sh"># Create an empty zeroed out 64MiB image file.
dd if=/dev/zero bs=1M count=0 seek=64 of=image.hdd

# Create a GPT partition table.
parted -s image.hdd mklabel gpt

# Create an ESP partition that spans the whole disk.
parted -s image.hdd mkpart ESP fat32 2048s 100%
parted -s image.hdd set 1 esp on

# Download the latest Limine binary release.
git clone https://github.com/limine-bootloader/limine.git --branch=v2.0-branch-binary --depth=1

# Build limine-install.
make -C limine

# Install the Limine BIOS stages onto the image.
./limine/limine-install image.hdd

# Mount the loopback device.
USED_LOOPBACK=$$(sudo losetup -Pf --show image.hdd)

# Format the ESP partition as FAT32.
sudo mkfs.fat -F 32 $${USED_LOOPBACK}p1

# Mount the partition itself.
mkdir -p img_mount
sudo mount $${USED_LOOPBACK}p1 img_mount

# Copy the relevant files over.
sudo mkdir -p img_mount/EFI/BOOT
sudo cp -v myos.elf limine.cfg limine/limine.sys img_mount/
sudo cp -v limine/BOOTX64.EFI img_mount/EFI/BOOT/

# Sync system cache and unmount partition and loopback device.
sync
sudo umount img_mount
sudo losetup -d $${USED_LOOPBACK}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">3. Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If everything above has been completed successfully, you should now have a bootable ISO or hard drive/USB image containing your 64-bit higher half stivale2 kernel and Limine to boot it. Once the kernel is successfully booted, you should see "Hello World" printed on screen.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_see_also">4. See Also</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/stivale/stivale/blob/master/STIVALE2.md">stivale2 specification</a></p>
</li>
<li>
<p><a href="https://github.com/FlorenceOS/Sabaton">The sabaton aarch64 stivale2 bootloader</a></p>
</li>
<li>
<p><a href="https://github.com/TomatOrg/TomatBoot">The TomatBoot x86\_64 UEFI stivale1 and 2 bootloader</a> (now archived)</p>
</li>
</ul>
</div>
</div>
</div>
</article>

            <footer>
                &copy; 2021 osdev.wiki contributors. All contents released under
                the Creative Commons Zero license. Icons (marked with class
                <code>bi</code>) provided by
                <a href="https://icons.getbootstrap.com/">Bootstrap Icons</a>
                under the MIT license.
                <a href="https://github.com/osdev-wiki/wiki/tree/main/">Source code</a>.
            </footer>
        </div>
    </body>
</html>
<!-- vim: set sw=4 et : -->

